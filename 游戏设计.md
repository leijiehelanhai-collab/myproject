# 项目设计书：BNB链通用焚化炉 (Universal Incinerator) - 幸运翻牌版

**版本**: 2.0 (High Roller Edition)
**日期**: 2025-11-30
**适用网络**: BNB Smart Chain (BSC)
**核心理念**: 游戏即服务 (Game as a Service)，结合“代币通缩销毁”与“PvP 翻牌比大小”的链上博弈平台。

---

## 1. 项目概述 (Executive Summary)

### 1.1 背景
本项目旨在构建一个高频、快节奏的链上销毁平台。不同于传统的无限期等待，本游戏采用**“限量座位 + 唯一数字”**机制，确保每一轮游戏都能快速结算。

### 1.2 核心玩法摘要
* **限量参与**：每轮游戏最多 **20个** 参与名额。
* **唯一数字**：系统预设 1-20 共20个号码。玩家入场时，系统随机分配一个**剩余的、不重复**的数字。
* **赢家通吃**：当20个名额满员（或倒计时结束），持有**数字最大**的玩家赢走当前奖池的所有 BNB。
* **销毁机制**：玩家必须销毁指定的“燃料代币”作为门票，持续制造通缩。

---

## 2. 经济模型 (Economic Model)

本游戏采用 **双代币混合结算机制**：

1.  **燃料代币 (Fuel Token)**：每一轮指定的第三方代币（如 $DOGE, $PEPE）。仅用于**销毁**，打入黑洞。
2.  **结算代币 (Settlement Token)**：固定为 **BNB**。用于支付入场费和发放奖励。

### 2.1 资金分配 (单次入场)
假设配置为：`销毁 1000 Token A` + `支付 0.05 BNB`。

* **Token A (燃料)**：100% -> **黑洞地址 (0x00...dEaD)**。
* **BNB (结算)**：
    * **80%** -> **本轮奖池 (Current Pot)**：累积给最终赢家。
    * **5%** -> **开发者手续费 (Dev Fee)**：项目方收入。
    * **15%** -> **下一轮储备金 (Next Round Reserve)**：滚入下一轮奖池，吸引新一轮玩家。

---

## 3. 游戏核心逻辑 (Game Mechanics)

### 3.1 随机数与唯一性逻辑
* **号码池**：每轮开始时，合约初始化一个数组 `[1, 2, 3 ... 20]`。
* **抽取机制**：
    * 玩家 A 进场，合约生成一个随机索引（基于区块哈希等）。
    * 假设抽中数字 `15`。玩家 A 获得 `15`。
    * **关键步骤**：将数组中最后一个数字（比如 `20`）移动到位置 `15`，并将数组长度减 1。
    * **结果**：下一个玩家绝对不可能再抽到 `15`，保证了数字的**唯一性**。

### 3.2 玩法流程 (User Flow)

1.  **开启轮次**：管理员设置本轮燃料代币（例如 $ABC），倒计时（例如 4 小时）。
2.  **玩家入场 (翻牌)**：
    * 玩家支付 BNB 和 $ABC。
    * 合约从剩余数字中随机分配一个数字给玩家（例如：Player1 翻到了 8）。
    * 前端显示：“你翻到了 8 号牌”。
3.  **结算触发条件**：满足以下 **任意一个** 条件即刻结算：
    * **条件 A (满员)**：第 20 名玩家入场，所有数字分配完毕。
    * **条件 B (超时)**：倒计时结束，但未满 20 人（例如只有 12 人参与）。
4.  **发奖 (Settle)**：
    * 系统对比所有已分配的数字。
    * 持有**最大数字**的玩家获胜。
    * BNB 奖池自动发送到该玩家钱包。

---

## 4. 智能合约架构 (Technical Architecture)

核心合约：`UniversalCardGame.sol`

### 4.1 核心数据结构

```solidity
struct Round {
    uint256 roundId;        // 轮次ID
    address tokenAddress;   // 本轮燃料代币
    uint256 burnAmount;     // 销毁数量
    uint256 ticketPrice;    // BNB门票价格
    uint256 startTime;      // 开始时间
    uint256 endTime;        // 截止时间
    uint256[] availableNumbers; // 当前剩余可用的数字池 [1...20]
    address[] participants;     // 参与者列表
    mapping(address => uint256) playerNumbers; // 记录玩家翻到的数字
    uint256 maxNumberHolderVal; // 当前最大的数字是多少
    address maxNumberHolder;    // 当前持有最大数字的人
    bool isEnded;           // 是否已结束
}

